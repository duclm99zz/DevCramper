// Generated by CoffeeScript 1.12.3
var EventEmitter, exec, local, ref, remote, spawn, stream;

EventEmitter = require('events').EventEmitter;

stream = require('stream');

ref = require('child_process'), exec = ref.exec, spawn = ref.spawn;

module.exports = function() {
  var callback, options;
  if (arguments.length === 1) {
    options = arguments[0];
  } else if (arguments.length === 2) {
    if (typeof arguments[1] === 'function') {
      options = arguments[0];
      callback = arguments[1];
    } else {
      options = {};
      options.ssh = arguments[0];
      options.cmd = arguments[1];
    }
  } else if (arguments.length === 3) {
    if (typeof arguments[2] === 'function') {
      callback = arguments[2];
      options = {};
    } else {
      options = arguments[2];
    }
    options.ssh = arguments[0];
    options.cmd = arguments[1];
  } else if (arguments.length === 4) {
    options = arguments[2];
    options.ssh = arguments[0];
    options.cmd = arguments[1];
    callback = arguments[3];
  } else {
    throw new Error('Invalid arguments');
  }
  if (options.ssh) {
    return remote(options, callback);
  } else {
    return local(options, callback);
  }
};

remote = module.exports.remote = function(options, callback) {
  var child, cmdOptions, stderr, stdout;
  child = new EventEmitter;
  child.stdout = new stream.Readable;
  child.stdout._read = function(_size) {};
  child.stderr = new stream.Readable;
  child.stderr._read = function() {};
  child.kill = function(signal) {
    if (signal == null) {
      signal = 'KILL';
    }
    if (child.stream) {
      return child.stream.signal(signal);
    }
  };
  stdout = stderr = '';
  if (options.cwd) {
    options.cmd = "cd " + options.cwd + "; " + options.cmd;
  }
  cmdOptions = {};
  if (options.env) {
    cmdOptions.env = options.env;
  }
  if (options.pty) {
    cmdOptions.pty = options.pty;
  }
  if (options.x11) {
    cmdOptions.x11 = options.x11;
  }
  options.ssh.exec(options.cmd, cmdOptions, function(err, stream) {
    var code, exit, exitCalled, signal, stderrCalled, stdoutCalled;
    if (err && callback) {
      return callback(err);
    }
    if (err) {
      return child.emit('error', err);
    }
    child.stream = stream;
    stream.stderr.on('data', function(data) {
      child.stderr.push(data);
      if (callback) {
        return stderr += data;
      }
    });
    stream.on('data', function(data) {
      child.stdout.push(data);
      if (callback) {
        return stdout += data;
      }
    });
    code = signal = null;
    exitCalled = stdoutCalled = stderrCalled = false;
    exit = function() {
      if (!(exitCalled && stdoutCalled && stderrCalled)) {
        return;
      }
      child.stdout.push(null);
      child.stderr.push(null);
      child.emit('close', code, signal);
      child.emit('exit', code, signal);
      if (code !== 0) {
        if (stderr.trim().length) {
          err = stderr.trim().split('\n');
          err = err[err.length - 1];
        } else {
          err = "Child process exited unexpectedly: code " + (JSON.stringify(code)) + ", signal " + (JSON.stringify(signal));
        }
        err = new Error(err);
        err.code = code;
        err.signal = signal;
      }
      if (options.end) {
        connection.end();
        connection.on('error', function(err) {
          return callback(err);
        });
        return connection.on('close', function() {
          if (callback) {
            return callback(err, stdout, stderr);
          }
        });
      } else {
        if (callback) {
          return callback(err, stdout, stderr);
        }
      }
    };
    stream.on('error', function(err) {
      return console.log('error', err);
    });
    stream.on('exit', function() {
      exitCalled = true;
      code = arguments[0], signal = arguments[1];
      return exit();
    });
    stream.on('end', function() {
      stdoutCalled = true;
      return exit();
    });
    return stream.stderr.on('end', function() {
      stderrCalled = true;
      return exit();
    });
  });
  return child;
};

local = module.exports.local = function(options, callback) {
  var cmdOptions;
  cmdOptions = {};
  cmdOptions.env = options.env || process.env;
  cmdOptions.cwd = options.cwd || null;
  if (options.uid) {
    cmdOptions.uid = options.uid;
  }
  if (options.gid) {
    cmdOptions.gid = options.gid;
  }
  if (callback) {
    return exec(options.cmd, cmdOptions, callback);
  } else {
    return spawn(options.cmd, [], Object.assign(cmdOptions, {
      shell: options.shell || true
    }));
  }
};
