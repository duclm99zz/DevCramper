// Generated by CoffeeScript 1.11.1
var docker, fs, merge, path, string, util,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  slice = [].slice;

module.exports = function(options, callback) {
  var cmd, dockerfile_cmds, i, j, k, l, len, len1, len2, number_of_step, opt, ref, ref1, ref2, ref3, source, userargs, v;
  options.log({
    message: "Entering Docker build",
    level: 'DEBUG',
    module: 'mecano/lib/docker/build'
  });
  if (options.docker == null) {
    options.docker = {};
  }
  ref = options.docker;
  for (k in ref) {
    v = ref[k];
    if (options[k] == null) {
      options[k] = v;
    }
  }
  if (options.image == null) {
    return callback(Error('Required option "image"'));
  }
  if ((options.content != null) && (options.file != null)) {
    return callback(Error('Can not build from Dockerfile and content'));
  }
  if (options.rm == null) {
    options.rm = true;
  }
  cmd = 'build';
  number_of_step = 0;
  userargs = [];
  dockerfile_cmds = ['CMD', 'LABEL', 'EXPOSE', 'ENV', 'ADD', 'COPY', 'ENTRYPOINT', 'VOLUME', 'USER', 'WORKDIR', 'ARG', 'ONBUILD', 'RUN', 'STOPSIGNAL', 'MAINTAINER'];
  source = null;
  if (options.file) {
    source = options.file;
  } else if (options.cwd) {
    source = options.cwd + "/Dockerfile";
  }
  if (options.file) {
    if (options.cwd == null) {
      options.cwd = path.dirname(options.file);
    }
  }
  ref1 = ['force_rm', 'quiet', 'no_cache'];
  for (i = 0, len = ref1.length; i < len; i++) {
    opt = ref1[i];
    if (options[opt]) {
      cmd += " --" + (opt.replace('_', '-'));
    }
  }
  ref2 = ['build_arg'];
  for (j = 0, len1 = ref2.length; j < len1; j++) {
    opt = ref2[j];
    if (options[opt] != null) {
      if (Array.isArray(options[opt])) {
        ref3 = options[opt];
        for (l = 0, len2 = ref3.length; l < len2; l++) {
          k = ref3[l];
          cmd += " --" + (opt.replace('_', '-')) + " " + k;
        }
      } else {
        cmd += " --" + (opt.replace('_', '-')) + " " + options[opt];
      }
    }
  }
  cmd += " --rm=" + (options.rm ? 'true' : 'false');
  cmd += " -t \"" + options.image + (options.tag ? ":" + options.tag : '') + "\"";
  if (options.cwd) {
    if (options.file == null) {
      options.file = path.resolve(options.cwd, 'Dockerfile');
    }
  }
  if (options.content != null) {
    options.log({
      message: "Building from text: Docker won't have a context. ADD/COPY not working",
      level: 'WARN',
      module: 'mecano/docker/build'
    });
    if (options.content != null) {
      cmd += " - <<DOCKERFILE\n" + options.content + "\nDOCKERFILE";
    }
  } else if (options.file != null) {
    options.log({
      message: "Building from Dockerfile: \"" + options.file + "\"",
      level: 'INFO',
      module: 'mecano/docker/build'
    });
    cmd += " -f " + options.file + " " + options.cwd;
  } else {
    options.log({
      message: "Building from CWD",
      level: 'INFO',
      module: 'mecano/docker/build'
    });
    cmd += ' .';
  }
  this.file({
    "if": options.content,
    content: options.content,
    source: source,
    target: function(content) {
      return options.content = content;
    },
    from: options.from,
    to: options.to,
    match: options.match,
    replace: options.replace,
    append: options.append,
    before: options.before,
    write: options.write
  });
  this.call({
    unless: options.content,
    handler: function(_, callback) {
      options.log({
        message: "Reading Dockerfile from : " + options.file,
        level: 'INFO',
        module: 'mecano/lib/build'
      });
      return fs.readFile(options.ssh, options.file, 'utf8', function(err, content) {
        if (err) {
          return callback(err);
        }
        options.content = content;
        return callback();
      });
    }
  });
  this.call(function() {
    var len3, line, m, ref4, ref5, ref6, results;
    ref4 = string.lines(options.content);
    results = [];
    for (m = 0, len3 = ref4.length; m < len3; m++) {
      line = ref4[m];
      if (ref5 = (ref6 = /^(.*?)\s/.exec(line)) != null ? ref6[1] : void 0, indexOf.call(dockerfile_cmds, ref5) >= 0) {
        results.push(number_of_step++);
      } else {
        results.push(void 0);
      }
    }
    return results;
  });
  this.execute({
    cmd: docker.wrap(options, cmd),
    cwd: options.cwd
  }, function(err, executed, stdout, stderr) {
    var container_id_hash, line, lines, number_of_cache;
    if (err) {
      throw err;
    }
    container_id_hash = null;
    lines = string.lines(stderr);
    lines = string.lines(stdout);
    number_of_cache = 0;
    for (k in lines) {
      line = lines[k];
      if (line.indexOf('Using cache') !== -1) {
        number_of_cache = number_of_cache + 1;
      }
      if (line.indexOf('Successfully built') !== -1) {
        container_id_hash = line.split(' ').pop().toString();
      }
    }
    return userargs = [number_of_step !== number_of_cache, container_id_hash, stdout, stderr];
  });
  return this.then(function(err, status) {
    if (err) {
      return callback(err);
    }
    options.log(userargs[0] ? {
      message: "New image id " + userargs[1],
      level: 'INFO',
      module: 'mecano/lib/docker/build'
    } : {
      message: "Identical image id " + userargs[1],
      level: 'INFO',
      module: 'mecano/lib/docker/build'
    });
    return callback.apply(null, [null].concat(slice.call(userargs)));
  });
};

docker = require('../misc/docker');

string = require('../misc/string');

path = require('path');

util = require('util');

fs = require('ssh2-fs');

merge = require('../misc').merge;
