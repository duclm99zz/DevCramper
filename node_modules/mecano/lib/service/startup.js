// Generated by CoffeeScript 1.11.1
var discover;

module.exports = function(options) {
  var modified;
  options.log({
    message: "Entering service.startup",
    level: 'DEBUG',
    module: 'mecano/lib/service/startup'
  });
  if (typeof options.argument === 'string') {
    if (options.name == null) {
      options.name = options.argument;
    }
  }
  if (options.startup == null) {
    options.startup = true;
  }
  if (Array.isArray(options.startup)) {
    options.startup = [options.startup];
  }
  if (options.name == null) {
    throw Error("Invalid Name: " + (JSON.stringify(options.name)));
  }
  options.log({
    message: "Startup service " + options.name,
    level: 'INFO',
    module: 'mecano/lib/service/startup'
  });
  modified = false;
  this.call(discover.loader, function() {
    return options.loader != null ? options.loader : options.loader = options.store['mecano:service:loader'];
  });
  this.call({
    "if": function() {
      return options.loader === 'service';
    },
    handler: function() {
      var do_disable, do_enable;
      do_enable = false;
      do_disable = false;
      this.call({
        shy: true,
        handler: function(_, callback) {
          return this.execute({
            cmd: "chkconfig --list " + options.name,
            shy: true,
            code_skipped: 1
          }, function(err, registered, stdout, stderr) {
            var c, current_startup, istr, j, len, level, ref, ref1, startup, status;
            if (err) {
              return callback(err);
            }
            if (/^error/.test(stderr)) {
              options.log({
                message: "Invalid chkconfig name for \"" + options.name + "\"",
                level: 'ERROR',
                module: 'mecano/service/startup'
              });
              return callback(new Error("Invalid chkconfig name for `" + options.name + "`"));
            }
            current_startup = '';
            if (registered) {
              ref = stdout.split(' ').pop().trim().split('\t');
              for (j = 0, len = ref.length; j < len; j++) {
                c = ref[j];
                ref1 = c.split(':'), level = ref1[0], status = ref1[1];
                if (['on', 'marche'].indexOf(status) > -1) {
                  current_startup += level;
                }
              }
            }
            istr = typeof options.startup === 'string';
            startup = istr ? true : options.startup;
            if (startup) {
              do_enable = (current_startup.length === 0) || (istr ? options.startup !== current_startup : false);
            } else {
              do_disable = registered && current_startup.length !== 0;
            }
            return callback(null, false);
          });
        }
      });
      this.call({
        "if": function() {
          return do_enable && !this.status(-1);
        },
        handler: function() {
          var cmd, i, j, startup_off, startup_on;
          cmd = "chkconfig --add " + options.name + ";";
          if (typeof options.startup === 'string') {
            startup_on = startup_off = '';
            for (i = j = 0; j < 6; i = ++j) {
              if (options.startup.indexOf(i) !== -1) {
                startup_on += i;
              } else {
                startup_off += i;
              }
            }
            if (startup_on) {
              cmd += "chkconfig --level " + startup_on + " " + options.name + " on;";
            }
            if (startup_off) {
              cmd += "chkconfig --level " + startup_off + " " + options.name + " off;";
            }
          } else {
            cmd += "chkconfig " + options.name + " on;";
          }
          return this.execute({
            cmd: cmd
          }, function(err) {
            if (err) {
              throw err;
            }
            return options.log({
              message: "Startup rules modified",
              level: 'INFO',
              module: 'mecano/service/startup'
            });
          });
        }
      });
      return this.call({
        "if": function() {
          return do_disable && !do_enable;
        },
        handler: function() {
          options.log({
            message: "Desactivating startup rules",
            level: 'DEBUG',
            module: 'mecano/service/startup'
          });
          return this.execute({
            cmd: "chkconfig " + options.name + " off"
          }, function(err, disabled, stdout, stderr) {
            if (err) {
              throw err;
            }
            return options.log({
              message: "Startup rules desactivating",
              level: 'INFO',
              module: 'mecano/service/startup'
            });
          });
        }
      });
    }
  });
  return this.call({
    "if": function() {
      return options.loader === 'systemctl';
    },
    handler: function() {
      this.execute({
        shy: true,
        cmd: "systemctl is-enabled " + options.name,
        code_skipped: 1
      });
      this.execute({
        "if": function() {
          return (!this.status(-1)) && options.startup;
        },
        cmd: "systemctl enable " + options.name
      });
      return this.execute({
        "if": function() {
          return this.status(-2) && (!options.startup);
        },
        cmd: "systemctl disable " + options.name
      });
    }
  });
};

discover = require('../misc/discover');
