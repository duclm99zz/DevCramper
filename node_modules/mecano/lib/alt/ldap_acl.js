// Generated by CoffeeScript 1.11.1
var each, wrap;

module.exports = function(goptions, options, callback) {
  var updated;
  if (options.acls == null) {
    options.acls = [{}];
  }
  updated = false;
  return each(options.acls).call(function(acl, next) {
    var b, client, connect, do_diff, end, i, j, len, parse, ref, save, search, stringify, unbind;
    if (acl.before == null) {
      acl.before = options.before;
    }
    if (acl.to == null) {
      acl.to = options.to;
    }
    if (acl.by == null) {
      acl.by = options.by;
    }
    client = null;
    acl.to = acl.to.trim();
    ref = acl.by;
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      b = ref[i];
      acl.by[i] = b.trim();
    }
    connect = function() {
      var ref1, ref2, ref3;
      if (((ref1 = options.ldap) != null ? (ref2 = ref1.url) != null ? (ref3 = ref2.protocol) != null ? ref3.indexOf('ldap') : void 0 : void 0 : void 0) === 0) {
        client = options.ldap;
        return search();
      }
      if (typeof options.log === "function") {
        options.log('Open and bind connection');
      }
      client = ldap.createClient({
        url: options.url
      });
      return client.bind(options.binddn, options.passwd, function(err) {
        if (err) {
          return end(err);
        }
        return search();
      });
    };
    search = function() {
      if (typeof options.log === "function") {
        options.log('Search attribute olcAccess');
      }
      return client.search(options.name, {
        scope: 'base',
        attributes: ['olcAccess']
      }, function(err, search) {
        var olcAccess;
        if (err) {
          return unbind(err);
        }
        olcAccess = null;
        search.on('searchEntry', function(entry) {
          if (typeof options.log === "function") {
            options.log("Found " + (JSON.stringify(entry.object)));
          }
          olcAccess = entry.object.olcAccess || [];
          if (!Array.isArray(olcAccess)) {
            return olcAccess = [olcAccess];
          }
        });
        return search.on('end', function() {
          if (typeof options.log === "function") {
            options.log("Attribute olcAccess was " + (JSON.stringify(olcAccess)));
          }
          return parse(olcAccess);
        });
      });
    };
    parse = function(_olcAccess) {
      var access, buf, buftype, bys, c, k, l, len1, len2, matches, olcAccess, to;
      olcAccess = [];
      for (i = k = 0, len1 = _olcAccess.length; k < len1; i = ++k) {
        access = _olcAccess[i];
        to = '';
        bys = [];
        buftype = 0;
        buf = '';
        for (i = l = 0, len2 = access.length; l < len2; i = ++l) {
          c = access[i];
          buf += c;
          if (buftype === 0) {
            if (/to$/.test(buf)) {
              buf = '';
              buftype = 1;
            }
          }
          if (buftype === 1) {
            if (matches = /^(.*)by$/.exec(buf)) {
              to = matches[1].trim();
              buf = '';
              buftype = 2;
            }
          }
          if (buftype === 2) {
            if (matches = /^(.*)by$/.exec(buf)) {
              bys.push(matches[1].trim());
              buf = '';
            } else if (i + 1 === access.length) {
              bys.push(buf.trim());
            }
          }
        }
        olcAccess.push({
          to: to,
          by: bys
        });
      }
      return do_diff(olcAccess);
    };
    do_diff = function(olcAccess) {
      var aby, access, fby, found, k, l, len1, len2, len3, len4, len5, m, n, o, oby, ref1, ref2, toAlreadyExist;
      toAlreadyExist = false;
      for (i = k = 0, len1 = olcAccess.length; k < len1; i = ++k) {
        access = olcAccess[i];
        if (acl.to !== access.to) {
          continue;
        }
        toAlreadyExist = true;
        fby = !options.overwrite ? access.by : [];
        ref1 = acl.by;
        for (l = 0, len2 = ref1.length; l < len2; l++) {
          oby = ref1[l];
          found = false;
          ref2 = access.by;
          for (m = 0, len3 = ref2.length; m < len3; m++) {
            aby = ref2[m];
            if (oby === aby) {
              found = true;
              break;
            }
          }
          if (!found) {
            updated = true;
            fby.push(oby);
          }
        }
        olcAccess[i].by = fby;
      }
      if (!toAlreadyExist) {
        updated = true;
        if (acl.before) {
          found = null;
          for (i = n = 0, len4 = olcAccess.length; n < len4; i = ++n) {
            access = olcAccess[i];
            if (access.to === acl.before) {
              found = i;
            }
          }
          olcAccess.splice(found - 1, 0, {
            to: acl.to,
            by: acl.by
          });
        } else if (acl.after) {
          found = false;
          for (i = o = 0, len5 = olcAccess.length; o < len5; i = ++o) {
            access = olcAccess[i];
            if (access.to === options.after) {
              found = i;
            }
          }
          olcAccess.splice(found, 0, {
            to: acl.to,
            by: acl.by
          });
        } else {
          olcAccess.push({
            to: acl.to,
            by: acl.by
          });
        }
      }
      if (updated) {
        return stringify(olcAccess);
      } else {
        return unbind();
      }
    };
    stringify = function(olcAccess) {
      var access, bie, k, l, len1, len2, ref1, value;
      for (i = k = 0, len1 = olcAccess.length; k < len1; i = ++k) {
        access = olcAccess[i];
        value = "{" + i + "}to " + access.to;
        ref1 = access.by;
        for (l = 0, len2 = ref1.length; l < len2; l++) {
          bie = ref1[l];
          value += " by " + bie;
        }
        olcAccess[i] = value;
      }
      return save(olcAccess);
    };
    save = function(olcAccess) {
      var change;
      change = new ldap.Change({
        operation: 'replace',
        modification: {
          olcAccess: olcAccess
        }
      });
      return client.modify(options.name, change, function(err) {
        return unbind(err);
      });
    };
    unbind = function(err) {
      var ref1, ref2, ref3;
      if (typeof options.log === "function") {
        options.log('Unbind connection');
      }
      if (((ref1 = options.ldap) != null ? (ref2 = ref1.url) != null ? (ref3 = ref2.protocol) != null ? ref3.indexOf('ldap') : void 0 : void 0 : void 0) === 0 && !options.unbind) {
        return end(err);
      }
      return client.unbind(function(e) {
        if (e) {
          return next(e);
        }
        return end(err);
      });
    };
    end = function(err) {
      return next(err);
    };
    return connect();
  }).then(function(err) {
    return next(err, updated);
  });
};

each = require('each');

wrap = require('../misc/wrap');
