// Generated by CoffeeScript 1.11.1
var ldap, misc, wrap;

module.exports = function(goptions, options, callback) {
  return wrap(arguments, function(options, next) {
    var client, connect, do_diff, end, get, parse, replace, stringifiy, unbind, updated;
    client = null;
    updated = false;
    connect = function() {
      var ref, ref1, ref2;
      if (((ref = options.ldap) != null ? (ref1 = ref.url) != null ? (ref2 = ref1.protocol) != null ? ref2.indexOf('ldap') : void 0 : void 0 : void 0) === 0) {
        client = options.ldap;
        return get();
      }
      client = ldap.createClient({
        url: options.url
      });
      return client.bind(options.binddn, options.passwd, function(err) {
        if (err) {
          return end(err);
        }
        return get();
      });
    };
    get = function() {
      return client.search('olcDatabase={2}bdb,cn=config', {
        scope: 'base',
        attributes: ['olcDbIndex']
      }, function(err, search) {
        var olcDbIndex;
        olcDbIndex = null;
        search.on('searchEntry', function(entry) {
          return olcDbIndex = entry.object.olcDbIndex;
        });
        return search.on('end', function() {
          return parse(olcDbIndex);
        });
      });
    };
    parse = function(arIndex) {
      var index, indexes, j, k, len, ref, v;
      indexes = {};
      for (j = 0, len = arIndex.length; j < len; j++) {
        index = arIndex[j];
        ref = index.split(' '), k = ref[0], v = ref[1];
        indexes[k] = v;
      }
      return do_diff(indexes);
    };
    do_diff = function(orgp) {
      var i, j, newp, nkl, okl, ref;
      if (!options.overwrite) {
        newp = misc.merge({}, orgp, options.indexes);
      } else {
        newp = options.indexes;
      }
      okl = Object.keys(orgp).sort();
      nkl = Object.keys(newp).sort();
      for (i = j = 0, ref = Math.min(okl.length, nkl.length); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        if (i === okl.length || i === nkl.length || okl[i] !== nkl[i] || orgp[okl[i]] !== newp[nkl[i]]) {
          updated = true;
          break;
        }
      }
      if (updated) {
        return stringifiy(newp);
      } else {
        return unbind();
      }
    };
    stringifiy = function(perms) {
      var indexes, k, v;
      indexes = [];
      for (k in perms) {
        v = perms[k];
        indexes.push(k + " " + v);
      }
      return replace(indexes);
    };
    replace = function(indexes) {
      var change;
      change = new ldap.Change({
        operation: 'replace',
        modification: {
          olcDbIndex: indexes
        }
      });
      return client.modify(options.name, change, function(err) {
        return unbind(err);
      });
    };
    unbind = function(err) {
      var ref, ref1, ref2;
      if (((ref = options.ldap) != null ? (ref1 = ref.url) != null ? (ref2 = ref1.protocol) != null ? ref2.indexOf('ldap') : void 0 : void 0 : void 0) === 0 && !options.unbind) {
        return end(err);
      }
      return client.unbind(function(e) {
        if (e) {
          return next(e);
        }
        return end(err);
      });
    };
    end = function(err) {
      return next(err, updated);
    };
    return connect();
  });
};

ldap = require('ldapjs');

misc = require('../misc');

wrap = require('../misc/wrap');
