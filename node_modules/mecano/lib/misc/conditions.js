// Generated by CoffeeScript 1.11.1
var each, exec, fs, template;

module.exports = {
  "if": function(options, succeed, skip) {
    var ok;
    if (!Array.isArray(options["if"])) {
      options["if"] = [options["if"]];
    }
    ok = true;
    return each(options["if"]).call((function(_this) {
      return function(si, next) {
        var err, type;
        if (!ok) {
          return next();
        }
        type = typeof si;
        if (si === null || type === 'undefined') {
          ok = false;
          return next();
        } else if (type === 'boolean' || type === 'number') {
          if (!si) {
            ok = false;
          }
          return next();
        } else if (type === 'function') {
          if (si.length < 2) {
            try {
              if (!si.call(_this, options)) {
                ok = false;
              }
              return next();
            } catch (error) {
              err = error;
              return next(err);
            }
          } else if (si.length === 2) {
            return si.call(_this, options, function(err, is_ok) {
              if (err) {
                return next(err);
              }
              if (!is_ok) {
                ok = false;
              }
              return next();
            });
          } else {
            return next(Error("Invalid argument length, expecting 2 or less, got " + si.length));
          }
        } else if (type === 'string' || (type === 'object' && Buffer.isBuffer(si))) {
          si = template(si.toString(), options);
          if (si.length === 0) {
            ok = false;
          }
          return next();
        } else {
          return next(Error("Invalid condition type: " + type));
        }
      };
    })(this)).then(function(err) {
      if (err || !ok) {
        return skip(err);
      } else {
        return succeed();
      }
    });
  },
  unless: function(options, succeed, skip) {
    var ok;
    if (!Array.isArray(options.unless)) {
      options.unless = [options.unless];
    }
    ok = true;
    return each(options.unless).call((function(_this) {
      return function(not_if, next) {
        var err, type;
        if (!ok) {
          return next();
        }
        type = typeof not_if;
        if (not_if === null || type === 'undefined') {
          ok = true;
          return next();
        } else if (type === 'boolean' || type === 'number') {
          if (not_if) {
            ok = false;
          }
          return next();
        } else if (type === 'function') {
          if (not_if.length < 2) {
            try {
              if (not_if.call(_this, options)) {
                ok = false;
              }
              return next();
            } catch (error) {
              err = error;
              return next(err);
            }
          } else if (not_if.length === 2) {
            return not_if.call(_this, options, function(err, is_ok) {
              if (err) {
                return next(err);
              }
              if (is_ok) {
                ok = false;
              }
              return next();
            });
          } else {
            return next(Error("Invalid callback"));
          }
        } else if (type === 'string' || (type === 'object' && Buffer.isBuffer(not_if))) {
          not_if = template(not_if.toString(), options);
          if (not_if.length !== 0) {
            ok = false;
          }
          return next();
        } else {
          return next(Error("Invalid condition type"));
        }
      };
    })(this)).then(function(err) {
      if (err || !ok) {
        return skip(err);
      } else {
        return succeed();
      }
    });
  },
  if_exec: function(options, succeed, skip) {
    return each(options.if_exec).call(function(cmd, next) {
      var run;
      if (typeof options.log === "function") {
        options.log({
          message: "Mecano `if_exec`: " + cmd,
          level: 'DEBUG',
          module: 'mecano/misc/conditions'
        });
      }
      options = {
        cmd: cmd,
        ssh: options.ssh
      };
      run = exec(options);
      if (options.stdout) {
        run.stdout.pipe(options.stdout, {
          end: false
        });
      }
      if (options.stderr) {
        run.stderr.pipe(options.stderr, {
          end: false
        });
      }
      return run.on("exit", function(code) {
        if (typeof options.log === "function") {
          options.log({
            message: "Mecano `if_exec`: code is \"" + code + "\"",
            level: 'INFO',
            module: 'mecano/misc/conditions'
          });
        }
        if (code === 0) {
          return next();
        } else {
          return skip();
        }
      });
    }).then(succeed);
  },
  unless_exec: function(options, succeed, skip) {
    return each(options.unless_exec).call(function(cmd, next) {
      var run;
      if (typeof options.log === "function") {
        options.log({
          message: "Mecano `unless_exec`: " + cmd,
          level: 'DEBUG',
          module: 'mecano/misc/conditions'
        });
      }
      options = {
        cmd: cmd,
        ssh: options.ssh
      };
      run = exec(options);
      if (options.stdout) {
        run.stdout.pipe(options.stdout, {
          end: false
        });
      }
      if (options.stderr) {
        run.stderr.pipe(options.stderr, {
          end: false
        });
      }
      return run.on("exit", function(code) {
        if (typeof options.log === "function") {
          options.log({
            message: "Mecano `unless_exec`: code is \"" + code + "\"",
            level: 'INFO',
            module: 'mecano/misc/conditions'
          });
        }
        if (code === 0) {
          return skip();
        } else {
          return next();
        }
      });
    }).then(succeed);
  },
  if_exists: function(options, succeed, skip) {
    var if_exists, ssh, target;
    ssh = options.ssh, if_exists = options.if_exists, target = options.target;
    if (typeof if_exists === 'boolean' && target) {
      if_exists = if_exists ? [target] : null;
    }
    return each(if_exists).call(function(if_exists, next) {
      return fs.exists(ssh, if_exists, function(err, exists) {
        if (exists) {
          if (typeof options.log === "function") {
            options.log({
              message: "File exists " + if_exists + ", continuing",
              level: 'DEBUG',
              module: 'mecano/misc/conditions'
            });
          }
          return next();
        } else {
          if (typeof options.log === "function") {
            options.log({
              message: "File doesnt exists " + if_exists + ", skipping",
              level: 'INFO',
              module: 'mecano/misc/conditions'
            });
          }
          return skip();
        }
      });
    }).then(succeed);
  },
  unless_exists: function(options, succeed, skip) {
    var ssh, target, unless_exists;
    ssh = options.ssh, unless_exists = options.unless_exists, target = options.target;
    if (typeof unless_exists === 'boolean' && target) {
      unless_exists = unless_exists ? [target] : null;
    }
    return each(unless_exists).call(function(unless_exists, next) {
      return fs.exists(ssh, unless_exists, function(err, exists) {
        if (exists) {
          if (typeof options.log === "function") {
            options.log({
              message: "File exists " + unless_exists + ", skipping",
              level: 'INFO',
              module: 'mecano/misc/conditions'
            });
          }
          return skip();
        } else {
          if (typeof options.log === "function") {
            options.log({
              message: "File doesnt exists " + unless_exists + ", continuing",
              level: 'DEBUG',
              module: 'mecano/misc/conditions'
            });
          }
          return next();
        }
      });
    }).then(succeed);
  },
  should_exist: function(options, succeed, skip) {
    return each(options.should_exist).call(function(should_exist, next) {
      return fs.exists(options.ssh, should_exist, function(err, exists) {
        if (exists) {
          return next();
        } else {
          return next(Error("File does not exist: " + should_exist));
        }
      });
    }).error(skip).then(succeed);
  },
  should_not_exist: function(options, succeed, skip) {
    return each(options.should_not_exist).call(function(should_not_exist, next) {
      return fs.exists(options.ssh, should_not_exist, function(err, exists) {
        if (exists) {
          return next(Error("File does not exist: " + should_not_exist));
        } else {
          return next();
        }
      });
    }).error(skip).then(function() {
      return succeed();
    });
  },
  all: function(context, options, succeed, failed) {
    var i, keys, next;
    if (!((options != null) && (typeof options === 'object' && !Array.isArray(options)))) {
      return succeed();
    }
    keys = Object.keys(options);
    i = 0;
    next = function() {
      var key;
      key = keys[i++];
      if (key == null) {
        return succeed();
      }
      if (key === 'all') {
        return next();
      }
      if (module.exports[key] == null) {
        return next();
      }
      return module.exports[key].call(context, options, next, function(err) {
        return failed(err);
      });
    };
    return next();
  }
};

each = require('each');

exec = require('ssh2-exec');

fs = require('ssh2-fs');

template = require('./template');
